# Memory and Pointer
## 返回指针
函数内分配指针指向堆内存，函数返回此指针才不会销毁  

**如果分配了内存但指针没返回，则指针在函数退出时销毁，内存泄漏**  
## RVO
如果对象是直接分配在栈空间的，反而不会内存泄漏，由于RVO（返回值优化）返回的实际是对象的拷贝（原始对象被销毁），而基本数据类型，如栈空间的c数组，由于本质上返回裸指针，会导致悬空指针  

注意这是返回值优化，而对于直接分配在栈空间的、没有返回的变量、实例，都会被销毁 **特别是返回链表指针时，链表内部自己创建的节点要用堆空间**
## 参数传递
对象参数传递  

（1）值传递 参数列表直接写对象类型

（2）引用传递 class& name 和指针类似，操作原对象，而且不需要指针解引用

## 隐藏的空指针解引用
空指针的解引用是危险的
```cpp
ListNode* dummy;
dummy->next=head;
```
此处会报错，因为dummy未初始化,不会分配内存，指向内存未知，`dummy->next` 本质是 `(*dummy).next`. 发生了错误解引用

而如下写法是可以的
```cpp
ListNode dummy;
dummy.next=head;
```
`dummy` 拥有栈空间，因此可以的访问 `next`
## new
new 语句的结果一定是一个指针,因此分配堆内存时只能分配给指针

**注意** `new` 语句的性能消耗比较大，最好不要在循环、函数中频繁使用
## 指针比较
`p1 == p2` 比较的是指针指向的地址，而非其指向值
## 指针拷贝
```cpp
//浅拷贝：指向同一内存
data* p1=new data(a);
data* p2=p1;
//深拷贝：独立内存
data* p1=new data(a);
data* p2=new data(*p1);
```
## 栈空间溢出
对于大数组，可以考虑开在全局变量区，也可以使用动态内存分配，但不要直接开在栈空间

最大约为 20w+ int


## 空指针传递
当空指针作为参数传递给函数时：

值传递：此时空指针不指向有效地址，给其分配空间和上级函数没有任何关系，因为 **他是新的空指针**

引用传递：空指针本身的地址没有变化，上级函数可以通过引用访问此空指针，他是 **原来的空指针**



