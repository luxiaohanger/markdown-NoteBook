# Inheritance  继承
## 单继承
```cpp
class derived-class: access-specifier base-class{

};
//冒号继承，注意末尾有分号
```
-----
***类成员的访问限制修饰***  
|访问|public|protected|private|
|----|-----|-----|-----|
|类内|yes|yes|yes|
|派生类|yes|yes|no|
|类外|yes|no|no|

类默认 private ， 结构体默认 public

函数重写时，可以自定义访问控制权限，但是权限是静态绑定的

函数重载一般要有一样的访问权限

----

***继承访问限制修饰符​***

`子类成员访问限制权限高于继承权限的降级为继承权限`

class 默认 private , struct 默认 public(不要忘了写继承修饰和访问修饰)

•
​​public 继承​​：基类成员的原始权限在派生类中​​保持不变​​

（public → public, protected → protected, private → 不可见）

•
​​protected 继承​​：public 降级为 protected

（public → protected, protected → protected, private→不可见）

•
​​private 继承​​：全部​​降级为 private​​

（public → private, protected → private, private → 不可见）  

***注意，C++中访问限制修饰符是写在内部，针对成员的，不存在对类本身的修饰***

### 继承范围

*一个派生类继承了所有的基类方法，但下列情况除外：*

基类的构造函数、析构函数和拷贝构造函数。
基类的重载运算符。
基类的友元函数。

## 多继承
```cpp
class <派生类名>:<继承方式1><基类名1>,<继承方式2><基类名2>,…
{
<派生类类体>
};

```
如果直接基类有公共的基类，则该公共基类中的成员变量在多继承的派生类中有多个副本

## 重载 Overloading
### 函数重载
`函数名一样，参数列表不同（返回值无所谓）`

重载查找与作用域相关，派生类同名函数会隐藏基类函数



| 特性         | 同一作用域内的函数重载                                     | 派生类中定义同名函数导致基类函数被隐藏                     |
| :----------- | :--------------------------------------------------------- | :--------------------------------------------------------- |
| **作用域**   | **同一个作用域内**（例如同一个类内部、全局作用域）。       | **不同作用域**（派生类作用域 vs 基类作用域）。             |
| **名称查找** | 编译器查找名称时，会**同时看到该作用域内的所有同名函数**。 | 编译器在派生类作用域**找到名称后即停止查找**，**不会**再去基类作用域查找同名名称。 |
| **可见性**   | 所有重载版本在名称查找阶段都是可见的。                     | 基类中的同名函数在派生类作用域内**不可见**（被隐藏），除非显式引入（如 `using`）。 |
| **重载解析** | 编译器在名称查找找到的所有同名函数中进行**重载解析**，选择参数最匹配的那个。 | **名称查找阶段**就决定了基类函数不会被考虑。**重载解析只在派生类找到的那个函数上进行**（如果参数不匹配，直接报错）。 |
| **错误类型** | 如果调用时没有参数匹配的重载版本，错误是 **“没有匹配的函数”**（重载解析失败）。 | 如果尝试调用被隐藏的基类函数（即使参数匹配），错误是 **“‘基类函数名’在‘派生类名’中不可访问”或类似**（名称查找失败）。 |
| **目的**     | 提供相同功能的不同接口（基于不同参数）。                   | **派生类引入新功能**或**有意覆盖基类行为**（即使参数不同）。 |
| **解决冲突** | 不需要特殊语法。                                           | 需要使用 `using Base::functionName;` 将基类函数引入派生类作用域，使其参与重载解析。 |



### 运算符重载
重载的运算符是带有特殊名称的函数，函数名是由关键字 `operator` 和其后要重载的运算符符号构成的

仿函数则是对函数调用运算符 `()` 进行重载

赋值运算符重载时注意考虑 `自赋值`
```cpp
class A{
    int val_a;
    int val_b;

    A operator+(const A& other) const { 
        return {
            val_a + other.val_a,
            val_b + other.val_b
        };
    }
};

//main
A a{1,2}; // 使用聚合初始化
A b{3,4};
//两种写法等价
A c = a.operator+(b);
A c = a + b;

//将流运算符重载作为友元函数以实现自定义输出
friend ostream& operator<<(ostream& os,const A& a){
    os << a.val_a << ' ' << a.val_b << endl;
    return os;
}
//cout << a;


```
