# Polymorphism 多态
## 虚函数
在基类中声明一个函数为虚函数，使用关键字 `virtual`。  

允许子类重写它（使用 `override` 关键字），从而在运行时通过基类指针或引用调用子类的重写版本，实现动态绑定。  

派生类可以选择性地重写虚函数，但不是必须。

重写函数自动成为虚函数,因此虚函数一旦声明就可以不断被派生类重写

### 核心机制总结
| **特性**       | **虚函数**                     | **非虚函数**                  |
|----------------|-------------------------------|------------------------------|
| **绑定方式**   | 动态绑定（运行时）             | 静态绑定（编译时）           |
| **决定因素**   | 对象的**动态类型**（实际类型） | 指针的**静态类型**（声明类型）|
| **调用规则**   | 调用本类虚函数表最终版本             | 调用基类版本                 |
| **实现机制**   | 通过虚函数表（vtable）查找     | 直接编译时确定地址           |

```cpp
class Base {
public:
    virtual void show() { 
        cout << "Base show" << endl; 
    }
};

class Derived : public Base {
public:
    void show() override {  // ✅ 正确重写
        cout << "Derived show" << endl;
    }
};
```
协变返回类型允许（派生类返回类型可以是基类返回类型的派生类）  

const 限定必须一致（同 const 或同非 const）

## 虚函数表
### 📌 虚函数表（vtable）的本质

1.  **每个类有自己的 vtable**
    *   每个包含虚函数（或继承虚函数）的类都有**自己独立的虚函数表**
    *   即使是派生类，也有自己的 vtable（继承自基类但可能被修改）
    *   **vtable 是按类创建的，不是按对象创建的**

2.  **vtable 的内容**
    *   vtable 是一个**函数指针数组**
    *   每个槽位（slot）对应类中的一个虚函数
    *   存放的是**该类提供的最新实现版本**的函数指针

### 📌 vtable 是如何构建的？

编译器在编译时为每个类生成 vtable，规则如下：

| 步骤 | 行为 |
|------|------|
| **1. 基类 vtable** | 按声明顺序包含所有虚函数的指针（指向基类自己的实现） |
| **2. 派生类 vtable** | 从基类复制 vtable 结构 |
| **3. 重写处理** | 如果派生类重写虚函数，**替换对应槽位的指针**为派生类版本 |
| **4. 新增虚函数** | 在 vtable **末尾添加**新槽位 |


### 📌 虚函数调用机制

当通过基类指针调用虚函数时：


1.  **获取 vptr**
    *   从对象头部获取虚表指针（vptr）→ 指向本类的 vtable

2.  **确定槽位位置**
    *   编译器知道 虚函数 在 vtable 中的位置
    

3.  **跳转到函数**
    *   访问 vtable[i] → 得到 `&X::func1`
    *   执行 `X::func1()`




## 纯虚函数和抽象类（接口）
纯虚函数是没有实现的虚函数，在基类中用 `= 0` 来声明。  

纯虚函数表示基类定义了一个接口，但具体实现由派生类负责。  

纯虚函数使得基类变为抽象类（abstract class），无法实例化。  

抽象类里面也可以有非抽象函数，可能为派生类共有的成员函数

纯虚函数参数规则与普通函数相同，派生类必须实现所有纯虚函数，实现时参数列表必须与声明严格匹配（除默认参数外，默认参数值在编译时根据​​静态类型​​确定，而非运行时动态类型）
```cpp
class Shape {
public:
    virtual int area() = 0;  // 纯虚函数，强制子类实现此方法
};
 
class Rectangle : public Shape {
private:
    int width, height;
public:
    Rectangle(int w, int h) : width(w), height(h) { }
    
    int area() override {  // 实现纯虚函数
        return width * height;
    }
};
```
## 基类指针指向派生类对象
和Java类似，基类指针可以指向派生类对象，但函数绑定有动态静态之分

**核心：静态绑定与动态绑定**  

函数是否动态绑定主要由虚函数关键字 `virtual` 决定：当函数是虚函数并且通过指针 / 引用调用时，才能动态绑定

*基类指针指向派生类对象时，对象的静态类型是基类，调用函数时：对于虚函数，会动态绑定，检查虚函数表；对于非虚函数，静态绑定只调用基类成员*


```cpp
Animal* animal = new Dog();
animal->speak();  
// 实际调用Dog::speak()而非Animal::speak()
// 静态类型：Animal*，变量声明的类型（编译时确定）
// 动态类型：Dog*,实际指向的对象类型（运行时确定）
```
### 虚析构函数
在基类指针指向派生类对象时，如果派生类含有指针和堆内存调用，基类析构函数必须是虚析构函数，避免内存泄漏

**delete函数检查对象是否有虚析构函数，通过虚函数表 vtable 查找实际虚构函数地址，调用后链式调用基类析构函数**  

```
定义一个函数为虚函数，不代表函数为不被实现的函数。

定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。

定义一个函数为纯虚函数，才代表函数没有被实现。

定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。
```
---------
为避免内存泄漏，在小规模（多态需求弱）场景下，直接使用派生类指针管理派生类对象更简单（相比基类指针+虚函数）