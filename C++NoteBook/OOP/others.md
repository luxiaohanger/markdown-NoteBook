本节用于介绍相关知识补充
## 内存
派生类继承于基类的变量不是副本，而是共享一个变量
## 构造和赋值
1.多数情况下，`T a = b;` 和 `T a(b);` 是等价的，这是调用构造函数的不同写法

2.当定义拷贝赋值运算符 / 移动赋值运算符 后；可以用 `=` 直接对已有实例赋值  
 `a = b;` (拷贝赋值)  
 `a = move(b);` (移动赋值)


## this 指针
this是一个隐藏的指针，可以在类的成员函数中使用，它可以用来指向调用对象

每一个对象都能通过 this 指针来访问自己的地址

当一个对象的成员函数被调用时，编译器会隐式地传递该对象的地址作为 this 指针

静态成员函数、友元函数没有 this 指针
## 友元
使用 `friend` 关键字，`在类内部声明，在类外部定义`（否则可能出现访问问题），友元函数 / 友元类 可以访问声明类的所有成员

友元不是任何类的成员，在类外部定义后直接调用,同理友元也没有 `this` 指针

友元的访问权限开放只针对声明此友元的类，对于其基类、派生类访问权限不变
```cpp
class MyClass {
private:
    int secretData;

    // 声明一个友元函数 (在类内部)
    friend void friendFunction(MyClass& obj);

    // 声明一个友元类 (在类内部)
    friend class FriendClass;

public:
    // ... 其他成员 ...
};

// 在类外部定义友元函数
void friendFunction(MyClass& obj) {
    obj.secretData = 42; // 可以访问私有成员 secretData
}

// 在别处定义友元类
class FriendClass {
public:
    void modifySecret(MyClass& obj) {
        obj.secretData = 100; // FriendClass 的成员函数可以访问 MyClass 的私有成员
    }
};
```
## 内联函数
C++习惯上把成员声明放在类定义内，把成员函数定义放在类外，在类定义中的定义的函数都是内联函数，即使没有使用 `inline` 说明符

## final
`final` 是一个​​上下文关键字

1.修饰虚函数，阻止派生类​​重写 (override)​​ 该虚函数,表明该虚函数是继承链的最终实现

2.修饰类，阻止该类被其他类​​继承​​。放在类定义的​​类名​​之后，`{` 之前

3.修饰纯虚函数，表明这个函数必须被实现，并且一旦实现就绑定不变
```cpp
virtual void mustBeImplemented() const = 0 final; 
```
## 函数返回引用
1.必须返回一个左值  
2.生命周期必须比函数长（例如成员变量）
3.返回值本身无需是引用类型

### OOP中什么时候返回引用
1.支持左值操作：直接修改函数返回值
2.运算符重载需要链式调用时：流、赋值


