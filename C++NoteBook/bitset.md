

### 1. **引入bitset头文件和初始化**
   - 首先需要包含头文件：`#include <bitset>`
   - 初始化`bitset`对象：
     - 从整数初始化：`bitset<大小> b(整数值);`，例如`bitset<8> b(42);` 将42转换为8位二进制。
     - 从字符串初始化：`bitset<大小> b("字符串");`，字符串只能包含'0'或'1'，例如`bitset<4> b("1010");`。
     - 默认初始化：所有位为0，例如`bitset<8> b;`。

### 2. **访问和修改位**
   - 使用下标操作符`[]`访问特定位（索引从0开始，从右向左）：
     ```cpp
     bitset<4> b("1010");
     bool bit0 = b[0]; // 获取最低位（最右边），值为0
     b[1] = 1;        // 设置第1位（从右数第2位）为1
     ```
   - 使用成员函数：
     - `test(pos)`：检查指定位是否为1，如果越界会抛出异常。
     - `set(pos)`：设置特定位为1。
     - `reset(pos)`：设置特定位为0。
     - `flip(pos)`：翻转特定位（0变1，1变0）。
     ```cpp
     bitset<4> b;
     b.set(0);    // 设置第0位为1
     b.reset(1);  // 设置第1位为0
     b.flip(2);   // 翻转第2位
     ```

### 3. **批量位操作**
   - 无参数调用时，操作所有位：
     - `set()`：将所有位设置为1。
     - `reset()`：将所有位设置为0。
     - `flip()`：翻转所有位。
     ```cpp
     bitset<4> b;
     b.set();     // b变为"1111"
     b.flip();    // b变为"0000"
     ```

### 4. **位运算**
   - `bitset`支持位运算符（如与、或、异或），返回新的`bitset`：
   时间复杂度为O(N/W)，其中W是机器字长
     ```cpp
     bitset<4> b1("1010"), b2("1100");
     auto b_and = b1 & b2; // 与运算，结果"1000"
     auto b_or = b1 | b2;  // 或运算，结果"1110"
     auto b_xor = b1 ^ b2; // 异或运算，结果"0110"
     ```
   - 也支持复合赋值运算符，如`&=`、`|=`、`^=`。

### 5. **转换和查询**
   - 转换为其他类型：
     - `to_ulong()` 或 `to_ullong()`：转换为无符号长整型（如果值过大可能抛出异常）。
     - `to_string()`：转换为字符串，可选参数指定填充字符（如`to_string('0', '1')`）。
     ```cpp
     bitset<4> b("1010");
     unsigned long val = b.to_ulong(); // 值为10
     string s = b.to_string();        // 字符串"1010"
     ```
   - 查询信息：
     - `size()`：返回位数。
     - `count()`：返回设置为1的位的数量。
     - `any()`：如果至少有一位为1，返回true。
     - `none()`：如果所有位为0，返回true。
     - `all()`：如果所有位为1，返回true（C++11新增）。
     ```cpp
     bitset<4> b("1010");
     cout << b.size();  // 输出4
     cout << b.count(); // 输出2（有2个1）
     ```

### 6. **其他实用函数**
   - 移位操作：支持左移`<<`和右移`>>`，空位补0。
     ```cpp
     bitset<4> b("0011");
     b = b << 1; // 左移一位，结果"0110"
     ```
   - 比较：支持比较运算符（如`==`、`!=`）。



