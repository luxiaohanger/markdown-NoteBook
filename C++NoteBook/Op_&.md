# Op_&
## 引用声明 
```cpp
int& b=a;
//b是a的一个别名，实际在内存中是同一块地址(不能绑定其他变量，声明必须初始化)
```
## 取地址符
```cpp
int* p= &a;
```
## 按引用传递参数
```cpp
void swap(int &a, int &b) {
    int temp = a;
    a = b;
    b = temp;
}
```
## 按位与
```cpp
int a = 5;     // 二进制 0101
int b = 3;     // 二进制 0011
int c = a & b; // 结果 0001（十进制 1）
```
## 函数返回引用
返回对象的别名（而非拷贝），可直接修改原始对象  
有利于链式调用、作为左值操作、避免大数据拷贝
```cpp
class StringBuilder {
    std::string data;
public:
    StringBuilder& append(const std::string& str) {
        data += str;
        return *this;  // 返回当前对象的引用
    }
};
// 链式调用
StringBuilder().append("Hello").append(" World");
```
**注意不要返回局部变量引用**

即使是实例，使用引用会导致绕过RVO！不涉及拷贝  
*一般参数传入引用，返回此引用，全程操作原变量*
## 成员函数&
用于限定成员函数的调用类型
```cpp
struct Foo {
    void print() & {
        cout << "左值对象调用\n";
    }
    void print() && {
        cout << "右值对象调用\n";
    }
};

int main() {
    Foo f;
    f.print();       // 左值对象 -> 调用 print() &
    Foo().print();   // 右值对象 -> 调用 print() &&
}
```
## 左值 / 右值 及其引用
 *  **左值 (lvalue)：**
    *   **核心特征：** 有**持久身份**（identity）。你可以获取它的内存地址（使用 `&` 操作符）。
    *   **通俗理解：** 它是一个**具名对象**，通常代表一个**持久存在**的实体。
    *   **例子：**
        *   变量名：`int x = 10;` 中的 `x`
        *   返回左值引用的函数调用：`int& getRef();`
        
    *   **生命周期：** 通常持续到其作用域结束。

 *  **右值 (rvalue)：**
    *   **核心特征：** 通常是**临时对象**或**字面量**（除了字符串字面量）。它没有持久身份，你**不能**获取它的内存地址（`&` 操作符不能作用于纯右值）。
    *   **通俗理解：** 它是一个**临时**的、**即将消亡**的值，通常出现在表达式的右边。
    *   **例子：**
        *   字面量（非字符串）：`42`, `3.14`, `true`
        *   返回非引用类型的函数调用：`int getValue();`
        *   算术表达式的结果：`x + y`
        *   逻辑表达式的结果：`x > y`
        *   类型转换的结果：`static_cast<int>(d)`
        *   **将亡值 (xvalue)：** 这是 C++11 引入的子类，特指那些生命周期即将结束、其资源可以被“移动”走的对象。这是右值引用的主要绑定目标。例如：`std::move(x)` 的结果、返回右值引用的函数调用（如 `std::move`）。
    *   **生命周期：** 通常只存在于其所在的完整表达式结束之前。

**简单记忆（不完全准确但实用）：**
*   **左值 = 有名字的、有地址的东西。**
*   **右值 = 临时的、没名字的、用完就丢的东西。**

### 左值引用 (lvalue reference) - `&`

这是我们熟悉的传统引用：

```cpp
int a = 10;
int &lref = a; // lref 是 a 的左值引用
```

*   **绑定目标：** 只能绑定到**左值**。
*   **目的：** 为现有对象提供别名，避免拷贝。常用于函数参数传递（避免拷贝大型对象）和返回值优化。
*   **限制：** 不能绑定到右值（临时对象）。
    ```cpp
    int &bad_ref = 10; // 错误！不能将左值引用绑定到右值（字面量 10）
    int &bad_ref2 = getValue(); // 错误！getValue() 返回一个临时值（右值）
    ```

### 右值引用 (rvalue reference) - `&&`

这是 C++11 引入的新引用类型：

```cpp
int &&rref = 42; // rref 是字面量 42 的右值引用
int &&rref2 = getValue(); // rref2 是 getValue() 返回的临时值的右值引用
```

*   **绑定目标：** 主要绑定到**右值**（特别是将亡值 xvalue）。
*   **目的：** 标识一个对象是“可移动的”（即将消亡的临时对象）。它允许我们安全地“窃取”这个临时对象的资源，而不是进行昂贵的深拷贝。这是实现**移动语义**的基础。
*   **关键特性：**
    *   延长了所绑定临时对象的生命周期，使其与右值引用变量的生命周期相同（在示例中，`42` 的生命周期被延长到 `rref` 的作用域结束）。
    *   但它最重要的用途是作为**函数参数**（尤其是移动构造函数和移动赋值运算符），让函数知道传入的对象是一个可以安全“掏空”的临时对象。

### `std::move` - 将左值“转换”为右值

*   **作用：** `std::move` 是一个**类型转换函数**。它不做任何实际的“移动”操作。它的唯一作用是将传入的**左值**或**左值引用**无条件地**转换**为**右值引用**（更具体地说，是转换为 xvalue）。
*   **目的：** 告诉编译器：“我明确地不再需要这个对象了（或者至少不关心它之后的状态），你可以把它当作一个临时对象（右值）来处理，允许移动其资源。”
*   **语法：**
    ```cpp
    #include <utility> // 需要包含此头文件
    MyVector v1(10);
    MyVector v2 (std::move(v1)); // 将 v1 (左值) 转换为右值引用，触发移动构造函数
    ```
*   **重要提示：**
    *   调用 `std::move(v1)` 后，**`v1` 的状态是未指定的！** 它通常处于一个“有效但为空”的状态（例如，内部指针被置为 `nullptr`，大小被置为 0）。**你不应该再使用 `v1` 的值**（除非你明确地给它重新赋值）。使用 `std::move` 意味着你放弃了对 `v1` 原有资源的所有权。
