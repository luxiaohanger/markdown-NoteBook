# Monotonic Stack 单调栈
## 特点
栈中元素严格递增/递减  

在每次入栈一个新元素时，为了维护栈的单调性，需要先将破坏单调性的元素弹出栈​​
## 适用类型
一维序列，从一端扫描，判断相邻或可见关系，关系只跟“最近的更高/更矮元素”有关

*关键词：下/上一个更大/小的元素 / 可见性 / 遮挡*  
左边/右边最近的满足某个条件的元素  
我是不是在不停地“淘汰掉一些候选人”？我是不是只关心“离我最近的更高/更矮”？

**一维已经很能说明问题了，尽量使用单调栈这类O(n)做法**  
一次扫描，如果更大就出栈（淘汰）  
找“更大”用​​递减栈​​；找“更小”用​​递增栈​​。

## 例题
### 最大二叉树
给定一个不重复的整数数组 `nums` , `最大二叉树` 可以用下面的算法从 `nums` 递归地构建:

创建一个根节点，其值为 `nums` 中的最大值。
递归地在最大值左边的子数组构建左子树。
递归地在最大值右边的子数组构建右子树。
返回 `nums` 构建的最大二叉树 。

#### 思路分析
一般方法使用递归 dfs O(n^2)

考虑 *某节点的父节点就是其 左边/右边下一个更大值*，符合单调栈模型

细节：左右都不存在，即为根节点；左右存一，即为父节点；左右都存在，则较小者为父节点

