# 排序
详见 OI-WIKI
## 稳定性
稳定性是指相等的元素经过排序之后相对顺序是否发生了改变。

基数排序、计数排序、插入排序、冒泡排序、归并排序是稳定排序。

选择排序、堆排序、快速排序、希尔排序不是稳定排序。
## 计数排序 Count sort
计数排序的时间复杂度为 𝑂(𝑛 +𝑤) ,其中 𝑤 代表待排序数据的值域大小。

因此计数排序是适用于 **小值域** 的稳定排序
```cpp
//元素最大值
int maxn = 100;

void count_sort(vector<int> &arr) {
    //计数数组
    vector<int> cnt(maxn);
    //排序后数组
    vector<int> ans(arr.size());

    for (int x: arr) {
        cnt[x]++;
    }

    //转为前缀和数组，含义为相应下标的元素在整个序列的位次（相等元素都记录为最大位次）
    for (int i = 1; i < maxn; ++i) {
        cnt[i] += cnt[i - 1];
    }

    for (int i = arr.size() - 1; i >= 0; --i) {
        //倒序排列元素，确保稳定性
        //arr[i] 排在相应的前缀和位置，同时减少计数
        ans[cnt[arr[i]] - 1] = arr[i];
        cnt[arr[i]]--;
    }
    //变答案为原始数组
    arr.swap(ans);
}
```
## 基数排序 Radix sort

将待排序的元素拆分为 𝑘
 个关键字，然后先对所有元素的第 𝑘
 关键字进行稳定排序，再对所有元素的第 𝑘 −1
 关键字进行稳定排序，再对所有元素的第 𝑘 −2
 关键字进行稳定排序……最后对所有元素的第 1
 关键字进行稳定排序，这样就完成了对整个待排序序列的稳定排序。

 适用于 **位数固定且每位关键字值域较小** 的序列，此时用 `计数排序` 作为内层稳定排序

 ## 桶排序 Bucket sort
适用于待排序数据 **值域较大但分布比较均匀** 的情况。

桶排序按下列步骤进行：

1.设置一个定量的数组当作空桶；

2.遍历序列，并将元素一个个放到对应的桶中；

3.对每个不是空的桶进行排序；

4.从不是空的桶里把元素再放回原来的序列中。



