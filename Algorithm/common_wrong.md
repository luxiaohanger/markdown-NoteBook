# 易错点
## 数据范围 
1.`N` 可能在 `int` 范围内，但中间步骤不一定，特别是有乘法的时候

2.`#define int long long` 可能会造成额外的开销，最好不要使用

3.含有取模的计算要频繁取，避免数据溢出

4.精度问题

注意类型提升陷阱：赋值表达式右侧计算时只考虑右侧类型提升，例如 `ld a = b / c;`如果  `b` 、 `c` 都是 `int` 类型，则右侧是整数除法运算，在赋值时才发生类型提升，可以改为 `ld a = b * 1.0L / c;`

同理，对于`long long a = b * c;`如果 `b`,`c` 是 `int` 类型，会发生溢出

| 优先级 | 类型                                         | 示例常量          |
| --- | ------------------------------------------ | ------------- |
| 1️⃣ | `long double`                              | `1.0L`        |
| 2️⃣ | `double`                                   | `1.0`         |
| 3️⃣ | `float`                                    | `1.0f`        |
| 4️⃣ | 整数提升（int / long long / unsigned long long） | `1`, `2`, `3` |

省事做法：虽然输入数据是 `int` ,但可以声明为 `double / ld`

| 用途     | 推荐函数          | 理由         |
| ------ | ------------- | ---------- |
| 求平方根   | ✅ `sqrt(x)`   | 更快、更准、类型匹配 |
| 求平方或立方 | ✅ 直接连乘        | 效率高        |
| 求任意浮点幂 | ✅ `pow(x, y)` | 通用性强       |


很多数学函数默认  `double` ,可以加后缀 l(long) / f(float) 控制

## 边界问题
1.注意 `while/for` 循环条件的边界

2.测试点编写要考虑很多情况，奇数偶数、边界、数据

3.分组迭代时，注意考虑除不尽的情况，组数是否+1、什么时候改变上界、下界对应关系

4.注意边界情况下开销数量级的改变，对数级可能退化为线性级

5.“头、尾、空”

## 内存管理
1.避免频繁使用堆空间分配，直接使用栈空间或者值传递性能更好

2.如果内存方面要求严格，可以考虑使用节省内存的数据类型，例如 `vector<bool>`,在C++中优化为占一位

3.用指针构造树时，注意 你操作的是指针，想要构建指针之间的关系必须通过父节点指向子节点（或者反过来）慎用指针赋值！小心空指针传递！
```cpp
prev -> left = ptr1;
ptr1 = ptr2;
//此时 ptr1 和 ptr2 指向同一节点，原来 ptr1 指向的节点仍然是 prev 的子节点
```
## 细节
1.写反`if` `while` ; `i` `j` ; `x` `y`; `m` `n`

2.`if` 语句忘加大括号（尤其是 `break`）导致代码逻辑错误

3.到底是返回下标还是返回数据，是什么不能重复

4.多加括号避免符号优先级问题，例如：解引用顺序

5.初始化：不要忘了初始化；不要初始化为影响结果的值

6.`cout` 输出时，不要忘记变量单独作为一栏，放在引号内就变成字符串了

7.库函数中使用随机访问迭代器为参数时，要注意 `左闭右开` 原则

8.数据更新时，注意更新的先后顺序有无影响

9.注意之前cin残留的换行符

10.符号书写要清楚，`>=` / `>`  ; `=` / `==`

11.当更换数据类型时，不要拉下某个变量

12.评测机和本地结果不一样，可能是发生了未定义行为，例如变量未初始化

13.对于多行、每行多个间隔的输入，注意操作流程中不要遗留垃圾输入（不能因为没用就不读入）

14.某些变量是为了方便书写的复制值，要修改时请回到原址修改

15.断点调试时尝试更换断点位置，加换行符

16.多组输出之间的换行不要忘记

17.注意多种情况考虑。例如迭代器查找返回 `end()`:1.没找到  2.空集

18.变量命名不要和保留字、标准库重合，例如 map

19.点被边连接不代表所有被连接的点在同一个连通分量中




